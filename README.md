# Реализация тестового задания на создание упрощенной вресии протокола RPC

Для использования достаточно создать экземлпяр класса и вызывать функцию запуска.

#include "RPC.h"

class RPC rpc;

rpc.Start();

Для осуществления запросов к другому устройству нужно вызывать функию 

rpc.SendRequest(const char *functionName, uint8_t *args, size_t argsLength, ResponseCallback callback);  
где:
- functionName - имя функции которую необходимо вызвать на удалнном устройстве
- args - аргументы для вызова удаленной функции
- argsLength - размер аргументов
- callback - функция вызываемая при получении ответа от удаленного устройства

Пример использования  
void EchoCallback(uint32_t id, uint8_t* data, size_t length, bool success) {  
    if (success) printf("Ответ на запрос %lu получен! Длина: %d\n", id, length);  
    else 		 printf("Ошибка в запросе %lu\n", id);

}


uint8_t data[] = {0x01, 0x02, 0x03};


rpc.SendRequest("Echo", data, sizeof(data), EchoCallback);


Для обработки запросов от других устройств нужно зарегистрировать фунцию при инициализации

void Echo(uint8_t* args, size_t argsLength, uint8_t*& response, size_t& responseLength)  
{  
    response = (uint8_t*)pvPortMalloc(argsLength);  
    memcpy(response, args, argsLength);  
    responseLength = argsLength;  
}

rpc.RegisterFunction("Echo", Echo);

При поступлении запроса на устройство будет вызывана функция из списка и отдан результат работы.


Слабые места в реализации:
1) Инициализция физического интерфейса пока сделана плохо. Необходимо сделать инициализацию внутри класса и обработку получения данных.
Также необходимо добавлять в stm32f4xx_it.c (файл с реализацией колбеков от прерываний)


void USART1_IRQHandler(void)  
{  
	if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE)) {  
		AddBuffer((uint8_t)(huart1.Instance->DR & 0xFF));  
	}  
  HAL_UART_IRQHandler(&huart1);  
}

в файле main.cpp добавить

#ifdef __cplusplus

extern "C" {

#endif


void AddBuffer(uint8_t data)

{
	rpc.AddBuffer(data);
}

#ifdef __cplusplus

}

#endif

2) Пока не сделан таймаут, значит ожидаение ответа может занять бесконечно долгое время.

Пожелания к улучшению:
1) В данной реализации как я понял могут быть только два устройства на одном интерфейсе. Потому как я не увидел требований к реализации маршрутизации к конечному устройству. Я думаю решается это добавлением в заголовок пакета поля "адрес устройства" - тогда в моменте получения данных можно будет определять кому был отправлен запрос. Но это накладывает дополнительную реализацию на инициализацию регистрации адресов у устройств.
2) Думаю стоит задуматься над безопасностью во время работы. По идее можно просто взять два устройства и логическим анализатором считать пакеты и сделать клон устройство. Возможно стоит сделать общий ключ шифрования для конкретной пары устройств. При старте сделать процесс аутентификации. Контроллер генерирует рандомное число, отправляет сообщение. Контроллер приняв сообщение, на основе общего ключа и полученного числа вычисляет подпись (считает контрольную сумму) и отдает ответ. Контроллер, получив ответ, вычисляет подпись уже у себя, аналогично как на другом устройстве и сравниает с полученной.
