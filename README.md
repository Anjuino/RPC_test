# Реализация тестового задания на создание упрощенной версии протокола RPC

Для использования достаточно создать экземлпяр класса и вызывать функцию запуска.

#include "RPC.h"

class RPC rpc;

rpc.Start();

Для осуществления запросов к другому устройству нужно вызывать функцию:

rpc.SendRequest(const char *functionName, uint8_t *args, size_t argsLength, ResponseCallback callback);  
где:
- functionName — имя функции, которую необходимо вызвать на удалённом устройстве;
- args — аргументы для вызова удаленной функции;
- argsLength — размер аргументов;
- callback — функция, вызываемая при получении ответа от удаленного устройства.

Пример использования  
void EchoCallback(uint32_t id, uint8_t* data, size_t length, bool success)  
{  
    if (success) printf("Ответ на запрос %lu получен! Длина: %d\n", id, length);  
    else 		 printf("Ошибка в запросе %lu\n", id);

}


uint8_t data[] = {0x01, 0x02, 0x03};


rpc.SendRequest("Echo", data, sizeof(data), EchoCallback);

--------------------------------------------------------------------------------------------------
Для обработки запросов от других устройств нужно зарегистрировать функцию при инициализации.

void Echo(uint8_t* args, size_t argsLength, uint8_t*& response, size_t& responseLength)  
{  
    response = (uint8_t*)pvPortMalloc(argsLength);  
    memcpy(response, args, argsLength);  
    responseLength = argsLength;  
}

rpc.RegisterFunction("Echo", Echo);

При поступлении запроса на устройство будет вызвана функция из списка, и будет возвращён результат её работы.

--------------------------------------------------------------------------------------------------

Слабые места в реализации:
1) Инициализация физического интерфейса пока сделана плохо. Необходимо сделать инициализацию внутри класса и обработку получения данных.
Также необходимо добавить в stm32f4xx_it.c (файл с реализацией колбэков от прерываний) следующий код:


	void USART1_IRQHandler(void)  
	{  
		if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE)) {  
			AddBuffer((uint8_t)(huart1.Instance->DR & 0xFF));  
		}  
	  HAL_UART_IRQHandler(&huart1);  
	}
	
	в файле main.cpp добавить
	
	#ifdef __cplusplus
	
	extern "C" {
	
	#endif
	
	
	void AddBuffer(uint8_t data)
	
	{
		rpc.AddBuffer(data);
	}
	
	#ifdef __cplusplus
	
	}
	
	#endif

2) Пока не сделан таймаут, значит ожидаение ответа может занять бесконечно долгое время.

Пожелания к улучшению:  
1)В данной реализации, как я понял, могут быть только два устройства на одном интерфейсе, потому что я не увидел требований к реализации маршрутизации к конечному устройству. Я думаю, это решается добавлением в заголовок пакета поля "адрес устройства" — тогда в момент получения данных можно будет определять, кому был отправлен запрос. Но это накладывает дополнительную сложность на реализацию регистрации адресов у устройств.  
2) Думаю, стоит задуматься над безопасностью во время работы. В идеале можно просто взять два устройства и логическим анализатором считать пакеты, чтобы сделать клон-устройство. Возможно, стоит сделать общий ключ шифрования для конкретной пары устройств. При старте можно реализовать процесс аутентификации: контроллер генерирует случайное число и отправляет сообщение. Контроллер, приняв сообщение, на основе общего ключа и полученного числа вычисляет подпись (считает контрольную сумму) и отдаёт ответ. Первый контроллер, получив ответ, вычисляет подпись у себя аналогичным образом и сравнивает её с полученной.
